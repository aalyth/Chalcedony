use crate::utils::PtrString;

/// The bytecode instructions, generated by the `codegen` of the interrpeter and
/// executed by the CVM (Chalcedony Vritual Machiine).
#[derive(Debug, Clone)]
pub enum Bytecode {
    /// Does nothing.
    Nop,

    /// Pushes the corresponding value on the top of the stack.
    ConstI(i64),
    ConstU(u64),
    ConstF(f64),
    ConstS(PtrString),
    ConstB(bool),

    /// Converts the top of the stack to a `CvmObjec::Int()`. Used to impicitly
    /// convert types of `Uint` to `Int`.
    CastI,

    /// Converts the top of the stack to a `CvmObjec::Float()`. Used to impicitly
    /// convert types of `Uint` and `Int` to `Float`.
    CastF,

    /// Pops the top 2 operators off the stack and performs the corresponding
    /// binary operation. The result is then pushed back on the stack.
    Add,
    Sub,
    Mul,
    Div,
    Mod,

    /// Pops the top 2 operators off the stack and performs the corresponding
    /// logical operation. A value of type `CvmObject::Bool()` is pushed on the stack.
    And,
    Or,
    Lt,
    Gt,
    Eq,
    LtEq,
    GtEq,

    /// Pops the top element off the stack, performs the corresponding unary operation
    /// and pushes back the resulting value on the stack.
    Neg,
    Not,

    /// Setters and getters for variables. Setting the value pops the top off
    /// the stack and replaces the value at the index. Getting the value pushes
    /// the corresponding variable's value onto the stack.

    /// Sets/gets variables from the CVM's globals hashmap.
    SetGlobal(usize),
    GetGlobal(usize),
    /// Sets/gets variables at the position:
    /// ```
    /// cvm.call_stack.top().unwrap().stack_length + idx
    /// ```
    SetArg(usize),
    GetArg(usize),
    /// Sets/gets variables at the position:
    /// ```
    /// let top_frame = cvm.call_stack.top().unwrap();
    /// top_frame.stack_length + top_frame.args_len + idx
    /// ```
    ///
    /// TODO: these bytecode instructions could be merged with the argument ones
    /// where the local variables' ids are tailored to the nubmer of function arguments.
    SetLocal(usize),
    GetLocal(usize),

    /// Creates a new function, whose body is the remaining of the passed bytecode
    /// instructions. The argument describes the number of arguments the function
    /// has.
    ///
    /// TODO: implementing the optimization for local variables' ids could remove
    /// the need to store the number of arguments the function takes.
    CreateFunc(usize),
    /// Calls the function with the given index. The function's arguments must
    /// already be present at the top N positions on the stack.
    CallFunc(usize),

    /// Both operations remove the top call frame from the CVM call stack and
    /// truncate the remaing stack length to `call_frame.stack_length`. The
    /// `Return` operation keeps the returned value on the top of the stack.
    Return,
    ReturnVoid,

    /// If the top of the stack is `CvmObject::Bool(false)` jumps forward N instructions.
    If(usize),
    /// Moves the instruction counter forward or backwards.
    Jmp(isize),

    /// Prints the top value off the stack.
    Print,
    /// Asserts the top 2 values on the stack are equal - if they are not, the
    /// script's execution is terminated.
    Assert,
}
