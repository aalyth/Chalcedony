//! Chalcedony - the type safe scripting language.
//!
//!
//! Commonly used acronyms:
//!  - `AST` - Abstract Syntax Tree - the intermediate representaion `IR`,
//!            generated by the parser
//!  - `CVM` - Chalcedony Virtual Machine - the structure, used to execute the
//!            script's bytecode instructions.
//!  - `RPN` - Reverse Polish Notation - a mathematical notation where instead
//!            of the operator being between the two operands, it is after the
//!            operands.
//!
//! For more information on each type of the interpreting process refer to the
//! modules `lexer`, `parser`, `vm` and `interpreter` (in that order).
//!
//! Future ideas:
//! [x] function overloading
//! [x] exceptions, try-catch blocks, and unsafe functions (ending with `!`)
//! [x] script importing and the `__main__` constant working
//! [x] lists and functions for them (`set!()`, `get!()`, `push()`, `pop!()`,
//!     `insert!()` and `remove!())
//! [x] `for in` loops over lists and iterators
//! [x] constants - the value can still be computed at runtime
//! [x] classes and methods
//! [x] `len()` function for strings and lists
//! [x] functions for type casts (such as `ftoi()`, `itou()`, `utof()`, etc.)
//!
//! [ ] traits
//! [ ] generic functions and members, and type bounds
//! [ ] hashmaps and  functions for them (`get!()`, `set!()`, etc.)
//! [ ] short circuit logic operators
//! [ ] a Chalcedony `shell` for direct execution of user commands
//! [ ] parallelism between lexer, parser, interpreter and vm

use chalcedony::interpreter::Chalcedony;

extern crate ahash;
extern crate itertools;

use std::env;

fn main() {
    let args: Vec<String> = env::args().collect();
    if args.len() != 2 {
        eprintln!("Error: expected only 1 argument - a file to execute");
        std::process::exit(1);
    }

    let mut interpreter = Chalcedony::new();
    interpreter.interpret_script(args[1].clone());
}
