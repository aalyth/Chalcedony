//! Chalcedony - the type safe scripting language.
//!
//!
//! Commonly used acronyms:
//!  - `AST` - Abstract Syntax Tree - the intermediate representaion `IR`,
//!            generated by the parser
//!  - `CVM` - Chalcedony Virtual Machine - the structure, used to execute the
//!            script's bytecode instructions.
//!  - `RPN` - Reverse Polish Notation - a mathematical notation where instead
//!            of the operator being between the two operands, it is after the
//!            operands.
//!
//! To-do list:
//! [x] exceptions, try-catch blocks, and unsafe functions (ending with `!`)
//! [ ] lists and functions for them (`set!()`, `get!()`, `push()`, `pop!()`,
//!     `insert!()` and `remove!())
//! [ ] `for in` loops over lists and iterators
//! [ ] constants - variables that could not be changed
//! [ ] classes and methods
//! [ ] `len()` function for strings and lists
//! [ ] generic functions
//! [ ] functions for type casts (such as `ftoi()`, `itou()`, `stoi!()`, etc.)
//! [ ] `std` functions such as `constains(list, el)`, `sort(list)`, `sin()`,
//!     `cos()`, `round()`, etc.
//! [ ] short circuit logic operators

use chalcedony::interpreter::Chalcedony;

extern crate ahash;
extern crate itertools;

use std::env;
use std::fs;

fn main() {
    let args: Vec<String> = env::args().collect();
    if args.len() != 2 {
        eprintln!("Error: expected only 1 argument - a file to execute");
        std::process::exit(1);
    }

    let Ok(script) = fs::read_to_string(args[1].clone()) else {
        eprintln!("Error: could not open the passed script");
        std::process::exit(1);
    };

    let mut interpreter = Chalcedony::new();
    interpreter.interpret(&script);
}
