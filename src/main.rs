//! Chalcedony - the type safe scripting language.
//!
//!
//! Commonly used acronyms:
//!  - `AST` - Abstract Syntax Tree - the intermediate representaion `IR`,
//!            generated by the parser
//!  - `CVM` - Chalcedony Virtual Machine - the structure, used to execute the
//!            script's bytecode instructions.
//!  - `RPN` - Reverse Polish Notation - a mathematical notation where instead
//!            of the operator being between the two operands, it is after the
//!            operands.
//!
//! Optimizations:
//! [-] reduce Bytecode instructions size (using unions instead of a big enum);
//!     N.B.: tried and it does not work - smaller instructions does not indeed
//!     mean a faster execution; the used method was the same as in python - the
//!     global constants are stored in a list inside the VM and the bytecode
//!     constants boil down to a clone() of the value at the given index
//! [x] remove the `arg_count` field from the `Cvm::CallFrame` struct
//!
//! to-do:
//! [ ] replace PtrString with a Box<String>
//! [ ] add continue and break to for loops
//! [ ] add iterators, instead of going through lists by index
//!
//! Future ideas:
//! [x] function overloading
//! [x] exceptions, try-catch blocks, and unsafe functions (ending with `!`)
//! [x] script importing and the `__main__` constant working
//! [%] lists and functions for them (`set!()`, `get!()`, `push()`, `pop!()`,
//!     `insert!()` and `remove!())
//! [%] `for in` loops over lists and iterators
//! [x] constants - variables that could not be changed
//! [ ] classes and methods
//! [x] `len()` function for strings and lists
//! [ ] generic functions
//! [ ] hashmaps and  functions for them (`get!()`, `set!()`, etc.)
//! [x] functions for type casts (such as `ftoi()`, `itou()`, `stoi!()`, etc.)
//! [ ] type casts from strings to primitive types
//! [ ] short circuit logic operators
//! [ ] a Chalcedony `shell` for direct execution of user commands

use chalcedony::interpreter::Chalcedony;

extern crate ahash;
extern crate itertools;

use std::env;

fn main() {
    let args: Vec<String> = env::args().collect();
    if args.len() != 2 {
        eprintln!("Error: expected only 1 argument - a file to execute");
        std::process::exit(1);
    }

    let mut interpreter = Chalcedony::new();
    interpreter.interpret_script(args[1].clone());
}
