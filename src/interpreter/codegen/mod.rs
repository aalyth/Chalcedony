//! The module responsible for compiling the `AST`, generated by the parser,
//! into the bytecode instructions, executed by the `CVM`.

pub mod class;
pub mod expr;
pub mod func;
pub mod stmnt;
pub mod var;

use crate::common::{Bytecode, Type};
use crate::error::{ChalError, CompileError, CompileErrorKind};
use crate::parser::ast::{NodeFuncCallStmnt, NodeImport, NodeProg};
use func::compile_func_call_inner;

use super::{Chalcedony, ScriptPath};

use std::path::{Path, PathBuf};

pub trait ToBytecode {
    fn to_bytecode(self, interpreter: &mut Chalcedony) -> Result<Vec<Bytecode>, ChalError>;
}

impl ToBytecode for NodeProg {
    fn to_bytecode(self, interpreter: &mut Chalcedony) -> Result<Vec<Bytecode>, ChalError> {
        match self {
            NodeProg::VarDef(node) => node.to_bytecode(interpreter),
            NodeProg::FuncDef(node) => node.to_bytecode(interpreter),
            NodeProg::FuncCall(NodeFuncCallStmnt(node)) => node.to_bytecode(interpreter),
            NodeProg::Assign(node) => node.to_bytecode(interpreter),
            NodeProg::IfStmnt(node) => node.to_bytecode(interpreter),
            NodeProg::WhileLoop(node) => node.to_bytecode(interpreter),
            NodeProg::TryCatch(node) => node.to_bytecode(interpreter),
            NodeProg::Import(node) => node.to_bytecode(interpreter),
            NodeProg::Class(node) => node.to_bytecode(interpreter),
        }
    }
}

impl ToBytecode for NodeImport {
    fn to_bytecode(self, interpreter: &mut Chalcedony) -> Result<Vec<Bytecode>, ChalError> {
        let script_path = match &interpreter.current_path {
            ScriptPath::Main => PathBuf::from(self.path.clone()),
            ScriptPath::Import(parent) => parent.join(&self.path),
        };

        if !script_path.exists() {
            return Err(CompileError::new(
                CompileErrorKind::ScriptNotFound(script_path.to_str().unwrap().to_string()),
                self.span,
            )
            .into());
        }

        let parent_path = interpreter.current_path.clone();
        interpreter.current_path =
            ScriptPath::Import(script_path.parent().unwrap_or(Path::new("")).into());

        let script_const_id = interpreter.get_global_id_internal("__name__", Type::Str, true);
        interpreter.vm.execute(vec![
            Bytecode::ConstS(interpreter.current_path.as_string().into()),
            Bytecode::SetGlobal(script_const_id),
        ]);

        interpreter.interpret_script(self.path);

        interpreter.current_path = parent_path;

        interpreter.vm.execute(vec![
            Bytecode::ConstS(interpreter.current_path.as_string().into()),
            Bytecode::SetGlobal(script_const_id),
        ]);
        Ok(Vec::new())
    }
}
